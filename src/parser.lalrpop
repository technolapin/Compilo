use std::str::FromStr;
use crate::ast::*;

grammar;


/////////////////////////
/////////////////////////
//// Statements /////////

StatDelimiter = ";";

pub Stat: Statement =
{
	<e: Expr> StatDelimiter => Statement::Expr(*e),
	PrimitiveSt,
	StatBlock,
}


/////////////////////////
// Primitives ///////////

PrimitiveSt: Statement =
{
	<prim: PrimitiveToken> "(" <e: Expr> ")" => Statement::Prim(prim, *e)
}

/////////////////////////
// PrimitivesTokens /////

PrimitiveToken: Primitive =
{
	"print" => Primitive::Print,
}

/////////////////////////
// StatBlock

StatBlock: Statement =
{
	"{" <v: StatList> "}" => Statement::StatBlock(v)
}

StatList: Vec<Statement> =
{
	Stat => vec![<>],
	<v: StatList> <st: Stat> => {let mut vmut = v; vmut.push(st); vmut},
}

Seq: (Vec<Statement>, Box<Expression>) =
{
	<s: StatList> <e: Expr> => (s, e)
}

SeqBlock: Box<Expression> =
{
	"{" <seq: Seq> "}" => Box::new(Expression::Seq(seq.0, seq.1))
}


/////////////////////////
// Expressions //////////

pub Expr: Box<Expression> =
{
	SeqBlock,
	Precedency17,
}

/////////////////////
// Identifiers //////


Identif =
{
	"_main",
	r#"(?:\nil)[[:alpha:]][[:word:]]*"#
}

/////////////////////
// Types ////////////

//Type: 




/////////////////////
// Declarations /////

Decls: Declaration =
{
	TypeDecl,
	ClassDecl,
	VarDecl,
	FunDecl,
	PrimDecl,
	MethDecl,
	ImportDecl
}

TypeDecl: Declaration =
{
//	"type" Identifier '=' Type
}
ClassDecl: Declaration = {}
VarDecl: Declaration = {}
FunDecl: Declaration = {}
PrimDecl: Declaration = {}
MethDecl: Declaration = {}
ImportDecl: Declaration = {}

/////////////////////
// Values ///////////

// only recognize positive numbers
// negatives ones will be recognised as a positive and a unary -
Int: u32 = <s:r"[0-9]+"> => u32::from_str(s).unwrap();
Nil: () = <s:r"nil"> => ();
String: String = <s: r#""[^"]*""#> => String::from(&s[1..s.len()-1]);

////////////////////////////////////
// Precedencies of operators ///////
// cf https://fr.cppreference.com/w/cpp/language/operator_precedence
// ready to implement *everything*

Precedency0: Box<Expression> =
{
	LiteralExpr,
	ParenthesisExpr
}

Precedency1: Box<Expression> =
{
	Precedency0
}

Precedency2: Box<Expression> =
{
	Precedency1,
	SufixIncrementExpr,
	SufixDecrementExpr
}

// moins unaire, not
Precedency3: Box<Expression> =
{
	Precedency2,
	MinusExpr,
	PlusExpr,
	NotExpr,
	PrefixIncrementExpr,
	PrefixDecrementExpr
}

Precedency4: Box<Expression> =
{
	Precedency3

}

Precedency5: Box<Expression> =
{
	Precedency4,
	MultExpr,
	DivExpr,
	ModuloExpr
}

// add sub
Precedency6: Box<Expression> =
{
	Precedency5,
	AddExpr,
	SubExpr,
}

Precedency7: Box<Expression> =
{
	Precedency6

}

// DONE
Precedency8: Box<Expression> =
{
	Precedency7,
	LessExpr,
	GreaterExpr,
	LessEqualExpr,
	GreaterEqualExpr

}

Precedency9: Box<Expression> =
{
	Precedency8,
	EqualExpr,
	NotEqualExpr,

}

Precedency10: Box<Expression> =
{
	Precedency9,
	BitAndExpr,
}

Precedency11: Box<Expression> =
{
	Precedency10,
	XorExpr

}

Precedency12: Box<Expression> =
{
	Precedency11,
	BitOrExpr,

}

Precedency13: Box<Expression> =
{
	Precedency12,
	AndExpr

}

Precedency14: Box<Expression> =
{
	Precedency13,
	OrExpr,
}

// I put If there for now, not in the list
Precedency15: Box<Expression> =
{
	Precedency14,
	IfExpr
	
}

Precedency16: Box<Expression> =
{
	Precedency15

}

Precedency17: Box<Expression> =
{
	Precedency16

}

//////////////////////////////
// Operators


// 0
LiteralExpr: Box<Expression> =
{
	Int => Box::new(Expression::Terminal(Terminal::Int(<>))),
	Nil => Box::new(Expression::Terminal(Terminal::Nil)),
	String => Box::new(Expression::Terminal(Terminal::String(<>)))
}

ParenthesisExpr: Box<Expression> =
{
	"(" <e: Expr> ")" => e
}


// 1
// 2
SufixDecrementExpr: Box<Expression> =
{
	<a: Precedency2> "--" => Box::new(Expression::Unary(Unop::Decrement, a))
}
SufixIncrementExpr: Box<Expression> =
{
	<a: Precedency2> "++" => Box::new(Expression::Unary(Unop::Increment, a))
}
// 3
PrefixDecrementExpr: Box<Expression> =
{
	"--" <a: Precedency3> => Box::new(Expression::Unary(Unop::Decrement, a))
}
PrefixIncrementExpr: Box<Expression> =
{
	"++" <a: Precedency3> => Box::new(Expression::Unary(Unop::Increment, a))
}
MinusExpr: Box<Expression> =
{
	<start:@L> "-" <a: Precedency3> <end:@R> => Box::new(Expression::Unary(Unop::Minus, a))
}
PlusExpr: Box<Expression> =
{
	"+" <a: Precedency3> => Box::new(Expression::Unary(Unop::Plus, a))
}
NotExpr: Box<Expression> =
{
	"!" <a: Precedency3> => Box::new(Expression::Unary(Unop::Not, a))
}

// 4

// 5
MultExpr: Box<Expression> =
{
	<a: Precedency5> "*" <b: Precedency4> => Box::new(Expression::Binary(Binop::Mul, a, b))

}

DivExpr: Box<Expression> =
{
	<a: Precedency5> "/" <b: Precedency4> => Box::new(Expression::Binary(Binop::Div, a, b))

}

ModuloExpr: Box<Expression> =
{
	<a: Precedency5> "%" <b: Precedency4> => Box::new(Expression::Binary(Binop::Modulo, a, b))

}

// 6
AddExpr: Box<Expression> =
{
	<a: Precedency6> "+" <b: Precedency5> => Box::new(Expression::Binary(Binop::Add, a, b))
}

SubExpr: Box<Expression> =
{
	<a: Precedency6> "-" <b: Precedency5> => Box::new(Expression::Binary(Binop::Sub, a, b))

}

//8
LessExpr: Box<Expression> =
{
	<a: Precedency8> "<" <b: Precedency7> => Box::new(Expression::Binary(Binop::Less, a, b))
}
GreaterExpr: Box<Expression> =
{
	<a: Precedency8> ">" <b: Precedency7> => Box::new(Expression::Binary(Binop::Greater, a, b))
}
LessEqualExpr: Box<Expression> =
{
	<a: Precedency8> "<=" <b: Precedency7> => Box::new(Expression::Binary(Binop::LessEqual, a, b))
}
GreaterEqualExpr: Box<Expression> =
{
	<a: Precedency8> ">=" <b: Precedency7> => Box::new(Expression::Binary(Binop::GreaterEqual, a, b))
}

// 9
EqualExpr: Box<Expression> =
{
	<a: Precedency9> "==" <b: Precedency8> => Box::new(Expression::Binary(Binop::Equal, a, b))
}
NotEqualExpr: Box<Expression> =
{
	<a: Precedency9> "!=" <b: Precedency8> => Box::new(Expression::Binary(Binop::NotEqual, a, b))
}

// 10
BitAndExpr: Box<Expression> =
{
	<a: Precedency10> "&" <b: Precedency9> => Box::new(Expression::Binary(Binop::BitAnd, a, b))
}
// 11
XorExpr: Box<Expression> =
{
	<a: Precedency11> "^" <b: Precedency10> => Box::new(Expression::Binary(Binop::Xor, a, b))
}
// 12
BitOrExpr: Box<Expression> =
{
	<a: Precedency12> "|" <b: Precedency11> => Box::new(Expression::Binary(Binop::BitOr, a, b))
}

// 13
AndExpr: Box<Expression> =
{
	<a: Precedency13> "&&" <b: Precedency12> => Box::new(Expression::Binary(Binop::And, a, b))
}

// 14
OrExpr: Box<Expression> =
{
	<a: Precedency14> "||" <b: Precedency13> => Box::new(Expression::Binary(Binop::Or, a, b))
}


// 15
IfExpr: Box<Expression> =
{
	"if" <cond: Precedency15> "then" <e1: Expr> "else" <e2: Expr> "end" =>
  	     Box::new(Expression::Ternary(Ternop::If, cond, e1, e2)),

}


