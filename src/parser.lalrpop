use std::str::FromStr;
use crate::ast::*;

grammar;


StatDelimiter = ";";

/////////////////////////
// Primitives ///////////


PrimitiveExpr: Box<Expression> =
{
	<prim: PrimitiveToken> "(" <e: Expr> ")" => Box::new(Expression::Primitive(prim, e))
}

/////////////////////////
// PrimitivesTokens /////

PrimitiveToken: Primitive =
{
	"print" => Primitive::Print,
}
pub Seq: Seq =
{
	SeqTerminate,
	SeqNonTerminate
}

SeqNonTerminate: Seq =
{
	SimpleExpr => Seq::new(*<>),
	<s: SeqNonTerminate> StatDelimiter <maybe_e: SimpleExpr?> =>
	if let Some(e) = maybe_e
	{
		Seq::pushed(s, *e)
	}
	else
	{
		Seq::pushed(s, Expression::Terminal(Terminal::Nil))
	}
}

SeqTerminate: Seq =
{
	ControlFlowExpr => Seq::new(*<>),
	<s: SeqNonTerminate> StatDelimiter <e: ControlFlowExpr> => Seq::pushed(s, *e)
}

SeqBlock: Box<Expression> =
{
	"{" <seq: Seq> "}" => Box::new(Expression::Block(seq)),
	"{" "}" => Box::new(Expression::Block(Seq::new(Expression::Terminal(Terminal::Nil))))
}


/////////////////////////
// Expressions //////////
pub Expr: Box<Expression> =
{
	SimpleExpr,
	ControlFlowExpr
}

SimpleExpr =
{
	Precedency17,
};

ControlFlowExpr: Box<Expression> =
{
	IfExpr,
}


/////////////////////
// Identifiers //////

pub Identif: Identifier =
{
	"_main" => Identifier::new(<>),
	r#"[[:alpha:]][[:word:]]*"# => Identifier::new(<>),
}

/////////////////////
// Types ////////////

//Type: 




/////////////////////
// Declarations /////

// Decls: Declaration =
// {
// 	TypeDecl,
// 	ClassDecl,
// 	VarDecl,
// 	FunDecl,
// 	PrimDecl,
// 	MethDecl,
// 	ImportDecl
// }

// TypeDecl: Declaration =
// {
// //	"type" Identifier '=' Type
// }
// ClassDecl: Declaration = {}
// VarDecl: Declaration = {}
// FunDecl: Declaration = {}
// PrimDecl: Declaration = {}
// MethDecl: Declaration = {}
// ImportDecl: Declaration = {}

/////////////////////
// Values ///////////

// only recognize positive numbers
// negatives ones will be recognised as a positive and a unary -
Int: i32 = <s:r"[0-9]+"> => u32::from_str(s).unwrap() as i32;
Nil: () = "nil" => ();
Bool: bool =
{
	"true" => true,
	"false" => false
}

String: String = <s: r#""[^"]*""#> => String::from(&s[1..s.len()-1]);

////////////////////////////////////
// Precedencies of operators ///////
// cf https://fr.cppreference.com/w/cpp/language/operator_precedence
// ready to implement *everything*

Precedency0: Box<Expression> =
{
	LiteralExpr,
	IdentifierExpr,
	ParenthesisExpr,
	PrimitiveExpr,
	SeqBlock,
}

Precedency1: Box<Expression> =
{
	Precedency0
}

Precedency2: Box<Expression> =
{
	Precedency1,
	SufixIncrementExpr,
	SufixDecrementExpr
}

// moins unaire, not
Precedency3: Box<Expression> =
{
	Precedency2,
	MinusExpr,
	PlusExpr,
	NotExpr,
	PrefixIncrementExpr,
	PrefixDecrementExpr
}

Precedency4: Box<Expression> =
{
	Precedency3

}

Precedency5: Box<Expression> =
{
	Precedency4,
	MultExpr,
	DivExpr,
	ModuloExpr
}

// add sub
Precedency6: Box<Expression> =
{
	Precedency5,
	AddExpr,
	SubExpr,
}

Precedency7: Box<Expression> =
{
	Precedency6

}

// DONE
Precedency8: Box<Expression> =
{
	Precedency7,
	LessExpr,
	GreaterExpr,
	LessEqualExpr,
	GreaterEqualExpr

}

Precedency9: Box<Expression> =
{
	Precedency8,
	EqualExpr,
	NotEqualExpr,

}

Precedency10: Box<Expression> =
{
	Precedency9,
	BitAndExpr,
}

Precedency11: Box<Expression> =
{
	Precedency10,
	XorExpr

}

Precedency12: Box<Expression> =
{
	Precedency11,
	BitOrExpr,

}

Precedency13: Box<Expression> =
{
	Precedency12,
	AndExpr

}

Precedency14: Box<Expression> =
{
	Precedency13,
	OrExpr,
}

// I put If there for now, not in the list
Precedency15: Box<Expression> =
{
	Precedency14,
	LetInExpr,
	
}

Precedency16: Box<Expression> =
{
	Precedency15

}

Precedency17: Box<Expression> =
{
	Precedency16
}




//////////////////////////////
// Operators


// 0
LiteralExpr: Box<Expression> =
{
	Int => Box::new(Expression::Terminal(Terminal::Int(<>))),
	Nil => Box::new(Expression::Terminal(Terminal::Nil)),
	String => Box::new(Expression::Terminal(Terminal::String(<>))),
	Bool => Box::new(Expression::Terminal(Terminal::Bool(<>))),

}

IdentifierExpr: Box<Expression> =
{
	Identif => Box::new(Expression::Identifier(<>))
}


ParenthesisExpr: Box<Expression> =
{
	"(" <e: Expr> ")" => e
}


// 1
// 2
SufixDecrementExpr: Box<Expression> =
{
	<a: Precedency2> "--" => Box::new(Expression::Unary(Unop::Decrement, a))
}
SufixIncrementExpr: Box<Expression> =
{
	<a: Precedency2> "++" => Box::new(Expression::Unary(Unop::Increment, a))
}
// 3
PrefixDecrementExpr: Box<Expression> =
{
	"--" <a: Precedency3> => Box::new(Expression::Unary(Unop::Decrement, a))
}
PrefixIncrementExpr: Box<Expression> =
{
	"++" <a: Precedency3> => Box::new(Expression::Unary(Unop::Increment, a))
}
MinusExpr: Box<Expression> =
{
	<start:@L> "-" <a: Precedency3> <end:@R> => Box::new(Expression::Unary(Unop::Minus, a))
}
PlusExpr: Box<Expression> =
{
	"+" <a: Precedency3> => Box::new(Expression::Unary(Unop::Plus, a))
}
NotExpr: Box<Expression> =
{
	"!" <a: Precedency3> => Box::new(Expression::Unary(Unop::Not, a))
}

// 4

// 5
MultExpr: Box<Expression> =
{
	<a: Precedency5> "*" <b: Precedency4> => Box::new(Expression::Binary(Binop::Mul, a, b))

}

DivExpr: Box<Expression> =
{
	<a: Precedency5> "/" <b: Precedency4> => Box::new(Expression::Binary(Binop::Div, a, b))

}

ModuloExpr: Box<Expression> =
{
	<a: Precedency5> "%" <b: Precedency4> => Box::new(Expression::Binary(Binop::Modulo, a, b))

}

// 6
AddExpr: Box<Expression> =
{
	<a: Precedency6> "+" <b: Precedency5> => Box::new(Expression::Binary(Binop::Add, a, b))
}

SubExpr: Box<Expression> =
{
	<a: Precedency6> "-" <b: Precedency5> => Box::new(Expression::Binary(Binop::Sub, a, b))

}

//8
LessExpr: Box<Expression> =
{
	<a: Precedency8> "<" <b: Precedency7> => Box::new(Expression::Binary(Binop::Less, a, b))
}
GreaterExpr: Box<Expression> =
{
	<a: Precedency8> ">" <b: Precedency7> => Box::new(Expression::Binary(Binop::Greater, a, b))
}
LessEqualExpr: Box<Expression> =
{
	<a: Precedency8> "<=" <b: Precedency7> => Box::new(Expression::Binary(Binop::LessEqual, a, b))
}
GreaterEqualExpr: Box<Expression> =
{
	<a: Precedency8> ">=" <b: Precedency7> => Box::new(Expression::Binary(Binop::GreaterEqual, a, b))
}

// 9
EqualExpr: Box<Expression> =
{
	<a: Precedency9> "==" <b: Precedency8> => Box::new(Expression::Binary(Binop::Equal, a, b))
}
NotEqualExpr: Box<Expression> =
{
	<a: Precedency9> "!=" <b: Precedency8> => Box::new(Expression::Binary(Binop::NotEqual, a, b))
}

// 10
BitAndExpr: Box<Expression> =
{
	<a: Precedency10> "&" <b: Precedency9> => Box::new(Expression::Binary(Binop::BitAnd, a, b))
}
// 11
XorExpr: Box<Expression> =
{
	<a: Precedency11> "^" <b: Precedency10> => Box::new(Expression::Binary(Binop::Xor, a, b))
}
// 12
BitOrExpr: Box<Expression> =
{
	<a: Precedency12> "|" <b: Precedency11> => Box::new(Expression::Binary(Binop::BitOr, a, b))
}

// 13
AndExpr: Box<Expression> =
{
	<a: Precedency13> "&&" <b: Precedency12> => Box::new(Expression::Binary(Binop::And, a, b))
}

// 14
OrExpr: Box<Expression> =
{
	<a: Precedency14> "||" <b: Precedency13> => Box::new(Expression::Binary(Binop::Or, a, b))
}


// 15
pub IfExpr: Box<Expression> =
{
	"if" <cond: Expr> "then" <seq1: Seq> "else" <seq2: Seq> =>
  	     Box::new(Expression::If(cond, seq1, seq2)),

}
LetInExpr: Box<Expression> =
{
	"let" <vars: DeclList> "in" <e: Seq> "end" =>
  	     Box::new(Expression::LetIn(vars, e)),

}

Decl: (Identifier, Expression) =
{
	"var" <ident: Identif> ":=" <e: Expr> => (ident, *e)
}

DeclList: VarsRegister =
{
	<tuple: Decl> => VarsRegister::with_first(tuple.0, tuple.1),
	<register: DeclList> <tuple: Decl> => register.with_added(tuple.0, tuple.1),
	
}


